# app/main.py
import os
import asyncio
from contextlib import suppress

# NEW: –ø–æ–¥—Ö–≤–∞—Ç—ã–≤–∞–µ–º .env –¥–æ —á—Ç–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
from dotenv import load_dotenv
load_dotenv()

from fastapi import FastAPI, Request, Header, Response
from fastapi.responses import PlainTextResponse, HTMLResponse, RedirectResponse
from markupsafe import escape

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.types import Update, BotCommand
from aiogram.exceptions import TelegramRetryAfter

from .memory_schema import (
    ensure_memory_schema_async,
    ensure_users_policy_column_async,
    ensure_users_created_at_column_async,
)
from .bot import router as bot_router

# NEW: –ø–æ–¥–∫–ª—é—á–∞–µ–º HTTP-—Ä–æ—É—Ç—ã –æ–ø–ª–∞—Ç—ã (–≤–µ–±—Ö—É–∫ –ÆKassa) –∏ –ª–µ–≥–∞–ª—å–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
from app.api import payments as payments_api  # NEW
from app.legal import router as legal_router   # NEW

# --- env (—Å—Ç—Ä–æ–≥–æ –µ–¥–∏–Ω—ã–µ –∏–º–µ–Ω–∞) ---
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
WEBHOOK_BASE_URL = os.getenv("WEBHOOK_BASE_URL", "").rstrip("/")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "")

if not BOT_TOKEN:
    raise RuntimeError("TELEGRAM_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω")
if not WEBHOOK_BASE_URL:
    raise RuntimeError("WEBHOOK_BASE_URL –Ω–µ –∑–∞–¥–∞–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä, https://<app>.onrender.com)")

WEBHOOK_PATH = "/telegram/webhook"  # –ø—É—Ç—å –æ—Å—Ç–∞—ë—Ç—Å—è –ø—Ä–µ–∂–Ω–∏–π
WEBHOOK_URL = f"{WEBHOOK_BASE_URL}{WEBHOOK_PATH}"

# === Watchdog: –∞–≤—Ç–æ-–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ–±—Ö—É–∫–∞, –µ—Å–ª–∏ –æ–Ω –ø—É—Å—Ç/—á—É–∂–æ–π ===
WATCHDOG_INTERVAL_SEC = int(os.getenv("WEBHOOK_WATCHDOG_SEC", "60"))

# aiogram 3.x
bot = Bot(BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
dp.include_router(bot_router)

app = FastAPI(title="ReflectAI webhook")

# NEW: —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º —Ä–æ—É—Ç–µ—Ä—ã
app.include_router(payments_api.router)  # /api/payments/yookassa/webhook
app.include_router(legal_router)         # /legal/requisites, /legal/offer

# ==== –ú–∏–Ω–∏-–ª–µ–Ω–¥–∏–Ω–≥ –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏ YooKassa ====

NAME = os.getenv("PROJECT_NAME", "–ü–æ–º–Ω–∏")
BOT_URL = os.getenv("PUBLIC_BOT_URL", "https://t.me/reflectttaibot")
MAIL = os.getenv("CONTACT_EMAIL", "selflect@proton.me")
OFFER = os.getenv("LEGAL_OFFER_URL", "")
POLICY = os.getenv("LEGAL_POLICY_URL", "")
INN = os.getenv("INN_SELFEMP", "")  # –ò–ù–ù —Å–∞–º–æ–∑–∞–Ω—è—Ç–æ–≥–æ

def _page(title: str, body: str) -> str:
    return f"""<!doctype html><meta charset="utf-8">
<title>{escape(title)}</title>
<meta name="robots" content="noindex,nofollow">
<style>
  body {{ font:16px/1.5 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial; max-width:720px; margin:40px auto; padding:0 16px; color:#111}}
  h1,h2 {{ margin:0 0 12px }} .muted{{color:#666}} a{{color:#136ef5; text-decoration:none}}
  .card{{border:1px solid #eee; border-radius:12px; padding:16px; margin:12px 0}}
</style>
{body}
"""

@app.get("/", response_class=HTMLResponse)
async def landing():
    return HTMLResponse(_page(
        f"{NAME} ‚Äî Telegram-–ø–æ–º–æ—â–Ω–∏–∫",
        f"""
        <h1>{escape(NAME)}</h1>
        <p class="muted">–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –∏ —Å–∞–º–æ-—Ä–µ—Ñ–ª–µ–∫—Å–∏—è –≤ Telegram.</p>
        <div class="card">
          <p>–ë–æ—Ç: <a href="{escape(BOT_URL)}">{escape(BOT_URL)}</a></p>
          <p>–ü–æ–¥–¥–µ—Ä–∂–∫–∞: <a href="mailto:{escape(MAIL)}">{escape(MAIL)}</a></p>
          <p>–°–∞–º–æ–∑–∞–Ω—è—Ç—ã–π, –ò–ù–ù: <b>{escape(INN or "‚Äî")}</b></p>
        </div>
        <p><a href="/requisites">–†–µ–∫–≤–∏–∑–∏—Ç—ã</a> ¬∑ <a href="/legal/policy">–ü–æ–ª–∏—Ç–∏–∫–∞</a> ¬∑ <a href="/legal/offer">–û—Ñ–µ—Ä—Ç–∞</a></p>
        """
    ))

@app.get("/requisites", response_class=HTMLResponse)
async def requisites():
    return HTMLResponse(_page(
        "–†–µ–∫–≤–∏–∑–∏—Ç—ã",
        f"""
        <h1>–†–µ–∫–≤–∏–∑–∏—Ç—ã</h1>
        <div class="card">
          <p>–°–∞–º–æ–∑–∞–Ω—è—Ç—ã–π (–ù–ü–î).</p>
          <p>–ò–ù–ù: <b>{escape(INN or "‚Äî")}</b></p>
          <p>E-mail: <a href="mailto:{escape(MAIL)}">{escape(MAIL)}</a></p>
          <p>Telegram: <a href="{escape(BOT_URL)}">{escape(BOT_URL)}</a></p>
        </div>
        """
    ))

@app.get("/legal/policy")
async def legal_policy():
    return RedirectResponse(POLICY or "/")

@app.get("/legal/offer")
async def legal_offer():
    return RedirectResponse(OFFER or "/")

# ==== /–ú–∏–Ω–∏-–ª–µ–Ω–¥–∏–Ω–≥ ====

async def _webhook_watchdog():
    backoff = 5
    try:
        while True:
            try:
                info = await bot.get_webhook_info()
                if info.url != WEBHOOK_URL:
                    print(f"[watchdog] webhook mismatch ('{info.url}') -> set '{WEBHOOK_URL}'")
                    await bot.set_webhook(url=WEBHOOK_URL, secret_token=WEBHOOK_SECRET, allowed_updates=[])
                    backoff = 5  # —Å–±—Ä–æ—Å –±—ç–∫–æ—Ñ—Ñ–∞
            except TelegramRetryAfter as e:
                wait = int(getattr(e, "retry_after", 1)) + 1
                print(f"[watchdog] retry_after {wait}s")
                await asyncio.sleep(wait)
            except Exception as e:
                print("[watchdog] error:", e)
                await asyncio.sleep(backoff)
                backoff = min(backoff * 2, 300)
            await asyncio.sleep(max(5, WATCHDOG_INTERVAL_SEC))
    except asyncio.CancelledError:
        pass

@app.get("/health")
async def health_get():
    return PlainTextResponse("ok")

@app.head("/health")
async def health_head():
    return Response(status_code=200)

@app.on_event("startup")
async def on_startup():
    # 1) —Å—Ö–µ–º–∞ –ë–î –º–∏–≥—Ä–∏—Ä—É–µ—Ç—Å—è Alembic; –∑–¥–µ—Å—å ‚Äî –¥–æ–ø. –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ä—ã—Ö —Ç–∞–±–ª–∏—Ü (async)
    await ensure_memory_schema_async()
    await ensure_users_policy_column_async()
    await ensure_users_created_at_column_async()

    # 2) —á–∏—Å—Ç–∏–º –≤–µ–±—Ö—É–∫ –∏ —Å—Ç–∞–≤–∏–º –∑–∞–Ω–æ–≤–æ
    try:
        await bot.delete_webhook(drop_pending_updates=True)
        ok = await bot.set_webhook(
            url=WEBHOOK_URL,
            secret_token=WEBHOOK_SECRET or None,
            allowed_updates=[],  # default –Ω–∞–±–æ—Ä
        )
        print(f"[startup] set_webhook: {ok} -> {WEBHOOK_URL}")
    except Exception as e:
        print("[startup] set_webhook ERROR:", repr(e))

    # 3) —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥
    try:
        await bot.set_my_commands([
            BotCommand(command="start",        description="‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç"),
            BotCommand(command="talk",         description="üí¨ –ü–æ–≥–æ–≤–æ—Ä–∏—Ç—å"),
            BotCommand(command="work",         description="üåø –†–∞–∑–æ–±—Ä–∞—Ç—å—Å—è"),
            BotCommand(command="meditations",  description="üéß –ú–µ–¥–∏—Ç–∞—Ü–∏–∏"),
            BotCommand(command="settings",     description="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏"),
            BotCommand(command="privacy",      description="üîí –ü—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å (–ø–∞–Ω–µ–ª—å)"),
            BotCommand(command="policy",       description="üìú –ü–æ–ª–∏—Ç–∏–∫–∞ –∏ –ø—Ä–∞–≤–∏–ª–∞"),
            BotCommand(command="about",        description="‚ÑπÔ∏è –û –ø—Ä–æ–µ–∫—Ç–µ"),
            BotCommand(command="help",         description="üÜò –ü–æ–º–æ—â—å"),
            BotCommand(command="pay",          description="üí≥ –ü–æ–¥–ø–∏—Å–∫–∞"),
        ])
    except Exception as e:
        print("[startup] set_my_commands ERROR:", repr(e))

    # 4) —Å—Ç–∞—Ä—Ç—É–µ–º watchdog (–µ—Å–ª–∏ —É–∂–µ –±—ã–ª ‚Äî –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ–º –≤—Ç–æ—Ä–æ–π —Ä–∞–∑)
    if not getattr(app.state, "webhook_watchdog", None):
        app.state.webhook_watchdog = asyncio.create_task(_webhook_watchdog())
        print("[startup] webhook watchdog started")

@app.on_event("shutdown")
async def on_shutdown():
    task = getattr(app.state, "webhook_watchdog", None)
    if task:
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            pass

# === —Å–∞–º –≤–µ–±—Ö—É–∫ (–±–µ–∑–æ–ø–∞—Å–Ω—ã–π) ===
@app.post(WEBHOOK_PATH)
async def telegram_webhook(
    request: Request,
    x_telegram_bot_api_secret_token: str = Header(default="")
):
    # 1) —Å–µ–∫—Ä–µ—Ç –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞ (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω)
    if WEBHOOK_SECRET and x_telegram_bot_api_secret_token != WEBHOOK_SECRET:
        return Response(status_code=403)

    # 2) —á–∏—Ç–∞–µ–º JSON
    data = await request.json()

    # 3) –ø—Ä–æ–±—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å; –ª—é–±—ã–µ —Å–±–æ–∏ –ª–æ–≥–∏—Ä—É–µ–º –∏ –≤—Å—ë —Ä–∞–≤–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 200
    try:
        update = Update.model_validate(data)  # pydantic v2
        msg_txt = None
        cb_data = None
        try:
            msg_txt = data.get("message", {}).get("text")
            cb_data = data.get("callback_query", {}).get("data")
        except Exception:
            pass
        print("[webhook] incoming:", msg_txt, "cb:", cb_data)

        await dp.feed_update(bot=bot, update=update)
    except Exception as e:
        import json, traceback
        msg = str(e)
        if "chat not found" in msg.lower():
            print("[webhook] ignore: chat not found; payload:",
                  json.dumps(data, ensure_ascii=False))
        else:
            print("[webhook] ERROR:", msg)
            print("payload:", json.dumps(data, ensure_ascii=False))
            traceback.print_exc()

    # –≤–∞–∂–Ω–æ: –≤—Å–µ–≥–¥–∞ 200, —á—Ç–æ–±—ã –¢–µ–ª–µ–≥–∞ –Ω–µ —Å–ø–∞–º–∏–ª–∞ —Ä–µ—Ç—Ä–∞—è–º–∏
    return PlainTextResponse("ok")
